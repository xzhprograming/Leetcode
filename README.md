# 链表
- 反转链表
- 反转前k个节点
- 链表有环问题
- 快慢指针

# LRU
双向链表 + Hash表

# 数组
头尾指针
快慢指针

# 滑动窗口
| #   | Title | Solution                                                                                 | Difficulty |
|-----| ----- |------------------------------------------------------------------------------------------|------------|
| 3   |[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) | [Java](src/doublepointer/slidewindow/Solution3.java) | Medium |

# 递归
递归是编程和数学中的一个重要概念，它指的是一个函数（或算法）直接或间接调用自身的处理方式。递归通常用于解决问题的分解，将问题分成更小但类型相同的子问题。为了防止无限递归导致的栈溢出错误，递归需要有一个或多个基本情况（也称为基准情况或终止条件），这些情况下可以直接给出答案而无需进一步递归。

递归的基本要素 
- 基准情况（Base Case）：这是递归终止的条件，避免了函数无限地调用自身。基准情况必须能够不依赖于递归来解决问题。 
- 递归步骤（Recursive Step）：在这个步骤中，函数会调用自己来解决比原问题规模更小的一个或多个子问题。通过逐步缩小问题规模，最终达到基准情况。


# 二叉树
## 二叉树解题的思维模式
1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。
无论使用哪种思维模式，你都需要思考：
如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

**引申扩展**：动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：

动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」。
回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。
DFS 算法属于遍历的思路，它的关注点在单个「节点」。
## 二叉树构造
核心思想：找到根节点，确定左子树和右子树范围边界，递归构造左右子树

1. 利用前序+中序构造
2. 利用后序+中序构造
3. 利用前序+后序构造（答案不唯一，前序和后序并不能唯一确定一棵二叉树，可以采用左子树不为空，则第二个节点为其左子树根节点的解法）

## 二叉搜索树（BST）
1. 二叉搜索树中序遍历是升序的
2. 左子树 < 根节点 < 右子树


# 回溯
回溯算法的核心思想是：尝试所有可能的选择，找到一个选择使得问题得到解决， 然后返回到上一个选择， 
并尝试下一个选择，直到找到一个选择使得问题得到解决，或者所有的选择都被尝试过。即进行选择，并撤销的

排列问题
1. 全排列
2. 
组合问题（也称子集问题）
1. 子集
2. [组合总和](https://leetcode.cn/problems/combination-sum/)


# 动态规划
动态规划的思想主要在状态转移方程
定义base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。


```angular2html
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```